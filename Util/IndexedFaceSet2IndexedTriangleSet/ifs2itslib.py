# (c) SenseGraphics 2010. Written for MOOG
# 17.06.2010
# Convert from IndexedFaceSet to IndexedTriangleSet for those IndexedFaceSets
# that are generated by other programs and have only 3-vertex polygons.
# The program will not work if the IndexedFaceSet contains a polygon with more than
# 3 vertices.
# Syntax: h3dload ifs2its.x3d [source_file] [destination_file]
# Demo: h3dload ifs2its.x3d face.x3d face_converted.x3d

from H3DInterface import *

import itertools
import operator
import random

# Generate normals for a ITS. return a list contains normals
# This is a python-converted of the function
# IndexedFaceSet::AutoNormal::generateNormalsPerVertex
def generateNormalsPerVertex(ITS):
  coords = ITS.coord.getValue().point.getValue()
  indexes = ITS.index.getValue()
  ccw = ITS.ccw.getValue()
  normals = [Vec3f(0, 0, 0)] * len(coords)
  
  for j in range(0, len(indexes), 3):
    if j+2 >= len(indexes):
      norm = Vec3f(1, 0, 0)
    else:
      A = coords[indexes[j]]
      B = coords[indexes[j+1]]
      C = coords[indexes[j+2]]
      AB = B - A
      BC = C - B
      norm = AB % BC
      norm.normalizeSafe()
      if not ccw: norm = - norm
      normals[indexes[ j ]] += norm;
      normals[indexes[ j+1 ]] += norm;
      normals[indexes[ j+2 ]] += norm;
  for normal in normals:
    normal.normalizeSafe()

  return normals


class Pack:
  def __init__(self):
    #self.texs = []  # all the texture (ID) of this coordinate
    self.texpoint = None
    self.next_coord_idx_ptr = -1 # point to the next index that contains point with the same coord as this point
    self.different = 0

# 2 (or more) points with same coordinate will have different
# normals since they connect to different triangles
# This function merge their normals together
def fixNormals(ITS):
  coords = ITS.coord.getValue().point.getValue()
  coords_visited = [0] * len(coords)
  normal_node = ITS.normal.getValue()
  normals = normal_node.vector.getValue()
  
  # this will take O(n^2) but it's modular (separate from the main prog)
  for i in range(len(coords)):
    if coords_visited[i]: continue
    coords_visited[i] = 1
    normal_sum = normals[i]
    adjacent_ids = [i] # list of coords that need to set to the same normal
    for j in range(i + 1, len(coords)):
      if (coords[i] - coords[j]).length() < 0.001:
        adjacent_ids += [j]
        normal_sum = normal_sum + normals[j]
        coords_visited[j] = 1
    for id in adjacent_ids:
      normals[id] = normal_sum
      normals[id].normalizeSafe()
  
  normal_node.vector.setValue(normals)

def ifs2its(IFS):
  """
    IFS: IndexedFaceSet
    Return: IndexedTriangleSet string
  """

  COORD = IFS.coord.getValue()
  TEX_COORD = IFS.texCoord.getValue()

  coord_idxs    = IFS.coordIndex.getValue()
  tex_idxs      = IFS.texCoordIndex.getValue()
  coord_points  = COORD.point.getValue()
  tex_points    = TEX_COORD.point.getValue()

  D = [ Pack() for i in range(len(coord_points)) ]

  group = createX3DNodeFromString("<Group />")[0]

  # remove -1
  coord_idxs = filter(lambda x: x != -1, coord_idxs)
  tex_idxs = filter(lambda x: x != -1, tex_idxs)
  
  # count number of new points (statistics purpose)
  count_newpoints = 0

  for i in range(len(coord_idxs)):
    ci = coord_idxs[i]
    ti = tex_idxs[i]

    if D[ci].texpoint == None: # first time encounter this coord
      D[ci].texpoint = tex_points[ti]
    else:
      tmp_id = ci
      # while the tex is still not the same, try to jump to the next point
      jump = 0
      while (tex_points[ti] - D[tmp_id].texpoint).length() > 0.00001 and D[tmp_id].next_coord_idx_ptr != -1:
        tmp_id = D[tmp_id].next_coord_idx_ptr
        jump += 1

      if (tex_points[ti] - D[tmp_id].texpoint).length() > 0.00001: # different tex_coord
        # create new point with same coordinate
        count_newpoints += 1
        D.append(Pack())
        D[tmp_id].next_coord_idx_ptr = len(D)-1
        D[len(D)-1].texpoint = tex_points[ti]
        coord_points.append(coord_points[ci])
        coord_idxs[i] = len(D)-1
      else:
        if jump > 0: coord_idxs[i] = tmp_id

  count_oldpoints = len(coord_points) - count_newpoints
  print '%i points added. Original: %i points. %f percent extra.' % (count_newpoints, count_oldpoints, count_newpoints * 100 / count_oldpoints)

  ans_tex_points = [None for i in range(len(coord_points))]
  for i in range(len(coord_idxs)):
    ci = coord_idxs[i]
    if ans_tex_points[ci] == None:
      ans_tex_points[ci] = D[ci].texpoint
    
  for i in range(len(ans_tex_points)):
    if not isinstance(ans_tex_points[i], Vec2f):
      ans_tex_points[i] = Vec2f(0.1, 0.5)

  its = createX3DNodeFromString("<IndexedTriangleSet />")[0]
  its.index.setValue(coord_idxs)
  coord_node = createX3DNodeFromString("<Coordinate />")[0]
  coord_node.point.setValue(coord_points)
  texcoord_node = createX3DNodeFromString("<TextureCoordinate />")[0]
  texcoord_node.point.setValue(ans_tex_points)
  its.coord.setValue(coord_node)
  its.texCoord.setValue(texcoord_node)
  
  normals = generateNormalsPerVertex(its)
  normalnode = createX3DNodeFromString("<Normal />")[0]
  normalnode.vector.setValue(normals)
  its.normal.setValue(normalnode)
  
  fixNormals(its)

  return writeNodeAsX3D(its)
